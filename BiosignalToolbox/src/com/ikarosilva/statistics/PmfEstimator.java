package com.ikarosilva.statistics;

import java.util.ArrayList;
import java.util.HashMap;
public class PmfEstimator {


	//px : 1 column= probability, 2nd column lower bound, 3rd column upper bound
	private double[][] pdf;
	private int Nbins;
	private int M;
	private double[][] minmax; //minimum and maximum values for bins (ie, range)

	public PmfEstimator(){
		Nbins=0;
	}

	public PmfEstimator(int Nbins){
		this.Nbins=Nbins;
	}
	public PmfEstimator(int Nbins, double[][] minmax){
		this.Nbins=Nbins;
		this.minmax=minmax;
	}

	private double[] minMax(double[] x){
		//Returns minmax (ie, range ) for a vector
		double[] minMax=new double[2];
		minMax[0]=Double.MAX_VALUE;
		minMax[1]=Double.MIN_VALUE;
		for(int i=0;i<x.length;i++){
			minMax[0]=(minMax[0]>x[i]) ? x[i]:minMax[0];
			minMax[1]=(minMax[1]<x[i]) ? x[i]:minMax[1];
		}
		return minMax;
	}

	public HashMap<Integer, Double> equipartition(double[][] x, int N){
		M=x.length;
		int samples=x[0].length;
		double wcount= (double) 1/samples;
		double[] range=new double[M];
		double[] binScale= new double[M];
		double[] step= new double[M];
		double[] unitScale= new double[M];
		double[] offset= new double[M];
		int key; 
		int binIndex=0;
		int[] mapDim=new int[M];
		Double tmp;
		HashMap<Integer,Double> pdf=new HashMap<Integer,Double>();



		//Initialize parameters for the the pmf
		if(Nbins ==0)
			Nbins=N;

		if(minmax == null){
			minmax=new double[M][2];
			for(int i=0;i<M;i++)
				minmax[i]=minMax(x[i]);
		}

		for(int i=0;i<M;i++)
		{
			range[i]= minmax[i][1]-minmax[i][0];
			binScale[i]=(double)(Nbins-1)/range[i];
			step[i]=(double)range[i]/Nbins;
			unitScale[i]=(minmax[i][1]+step[i])/minmax[i][1];
			offset[i]=(double)step[i]/2;
			mapDim[i]=(int) Math.pow(Nbins,M-i-1);
			System.out.println("Dim " + i +" : range= " + range[i]
					+ " step= " + step[i]+ " binScale= "+ binScale[i]
				    + " unit= " + unitScale[i] + 
				    " offset= " + offset[i] + " mapdim=" + mapDim[i]);
		}
		/*
		Create HashMap to store bin locations of X1 , X2,...XM
		and use the HashMap to add to the count. The HashMap is created 
		by normalizing the respective variables and multiplying by the 
		number of bins. The keys to the location in them map are generated by:
			round(normalized*Nbins)  
		TODO: ensure capacity ??
		 */
		double norm;
		for(int i=0;i<samples;i++){
			key=0;
			for(int j=0;j<M;j++){
				//Find the bin location of the sample
				norm=( (x[j][i]-minmax[j][0])*unitScale[j] )-offset[j];
				binIndex= (int) Math.round(norm*binScale[j]);
				
				//Use integer division to have Nbins*binIndex  
				//on all except last dimension
				key+= (double) mapDim[j]*binIndex; 
				System.out.print("x[" + j + "][" + i +"]= " + x[j][i]+
						" binIndex=" + binIndex + "   " );
			}
			//Map subscript to absolute index
			System.out.println("key= "+ key);
			tmp=pdf.get(key);
			tmp=(tmp == null) ? wcount:tmp+wcount;
			pdf.put(key,tmp);
		}

		//Print HashMap
		System.out.println("map size=" + pdf.size());
		int[] indices=new int[M];
		for(Integer thisKey : pdf.keySet()){
			indices[0]=(int) Math.floor(thisKey/mapDim[0]);
			System.out.print
			( thisKey + " / " + mapDim[0] +" =" + indices[0] + " -> ");
			for(int i=1;i<M;i++){
				indices[i]=thisKey;
				for(int k=0;k<i;k++){
					System.out.println
					( thisKey + " - " +indices[k] + "*" + mapDim[k]);
					indices[i]-=indices[k]*mapDim[k];
				}
				
			}
			System.out.print("pdf[ " + thisKey +" : ");
			for(int j=0;j<M;j++){
				System.out.print(indices[j] + " ");
			}
			System.out.println("] = " + pdf.get(thisKey));
		}
		
		return pdf;

	}


	public static void main(String[] args) {

		//Test the histogram estimation
		ArrayList<Double> y= new ArrayList<Double>();
		HashMap<Integer,Double> hist;
		int samples=16, bins=4;
		int dim=2;
		double[][] x= new double[dim][samples];
		for(int n=0;n<samples;n++){
			for(int d=0;d<dim;d++)
				x[d][n]=n;
		}
		PmfEstimator pdf=new PmfEstimator(bins);
		hist=pdf.equipartition(x,bins);
	}

}
