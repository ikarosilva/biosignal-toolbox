package com.ikarosilva.statistics;

import java.util.ArrayList;
import java.util.HashMap;
public class PmfEstimator {


	//px : 1 column= probability, 2nd column lower bound, 3rd column upper bound
	private double[][] pmf;
	private HashMap<Integer,Double> pmfHashMap;
	private int Nbins;
	private int M;
	private double[][] minmax; //minimum and maximum values for bins (ie, range)
	int[] mapDim;

	public PmfEstimator(){
		Nbins=0;
	}

	public PmfEstimator(int Nbins){
		this.Nbins=Nbins;
	}
	public PmfEstimator(int Nbins, double[][] minmax){
		this.Nbins=Nbins;
		this.minmax=minmax;
	}

	private double[] minMax(double[] x){
		//Returns minmax (ie, range ) for a vector
		double[] minMax=new double[2];
		minMax[0]=Double.MAX_VALUE;
		minMax[1]=Double.MIN_VALUE;
		for(int i=0;i<x.length;i++){
			minMax[0]=(minMax[0]>x[i]) ? x[i]:minMax[0];
			minMax[1]=(minMax[1]<x[i]) ? x[i]:minMax[1];
		}
		return minMax;
	}

	public void equipartition(double[][] x, int N){
		M=x.length;
		int samples=x[0].length;
		double wcount= (double) 1/samples;
		double[] range=new double[M];
		double[] binScale= new double[M];
		double[] step= new double[M];
		double[] unitScale= new double[M];
		double[] offset= new double[M];
		int key; 
		int binIndex=0;
		pmfHashMap=new HashMap<Integer,Double>();
		mapDim=new int[M];
		Double tmp;
		//Initialize parameters for the the pmf
		if(Nbins ==0)
			Nbins=N;
		if(minmax == null){
			minmax=new double[M][2];
			for(int i=0;i<M;i++)
				minmax[i]=minMax(x[i]);
		}

		for(int i=0;i<M;i++)
		{
			range[i]= minmax[i][1]-minmax[i][0];
			binScale[i]=(double)(Nbins-1)/range[i];
			step[i]=(double)range[i]/Nbins;
			unitScale[i]=(minmax[i][1]+step[i])/minmax[i][1];
			offset[i]=(double)step[i]/2;
			mapDim[i]=(int) Math.pow(Nbins,M-i-1);
		}
		/*
		Create HashMap to store bin locations of X1 , X2,...XM
		and use the HashMap to add to the count. The HashMap is created 
		by normalizing the respective variables and multiplying by the 
		number of bins. The keys to the location in them map are generated by:
			round(normalized*Nbins)  
		TODO: ensure capacity ??
		 */
		double norm;
		for(int i=0;i<samples;i++){
			key=0;
			for(int j=0;j<M;j++){
				//Find the bin location of the sample
				norm=( (x[j][i]-minmax[j][0])*unitScale[j] )-offset[j];
				binIndex= (int) Math.round(norm*binScale[j]);
				//Use integer division to have Nbins*binIndex  
				//on all except last dimension
				key+= (double) mapDim[j]*binIndex; 
			}
			//Map subscript to absolute index
			tmp=pmfHashMap.get(key);
			tmp=(tmp == null) ? wcount:tmp+wcount;
			pmfHashMap.put(key,tmp);
		}
	}

	public void printHashMap(){
		int[] indices;
		for(Integer thisKey : pmfHashMap.keySet()){
			indices=sub2Indices(thisKey);
			System.out.print("pmf[ " + thisKey + " : ");
			for(int j=0;j<M;j++){
				System.out.print(indices[j] + " ");
			}
			System.out.println(" ]=" + pmfHashMap.get(thisKey));
		}
	}

	public int[] sub2Indices(Integer sub){
		int[] indices=new int[M];
		indices[0]=(int) Math.floor(sub/mapDim[0]);
		for(int i=1;i<M;i++){
			indices[i]=sub;
			for(int k=0;k<i;k++)
				indices[i]-=indices[k]*mapDim[k];
		}
		return indices;
	}

	
	public static void main(String[] args) {
		//Test the histogram estimation
		ArrayList<Double> y= new ArrayList<Double>();
		HashMap<Integer,Double> hist;
		int bins=5;
		int samples=bins*10;
		int dim=2;
		double[][] x= new double[dim][samples];
		for(int n=0;n<samples;n++){
			for(int d=0;d<dim;d++)
				x[d][n]=n;
		}
		PmfEstimator pmf=new PmfEstimator(bins);
		pmf.equipartition(x,bins);
		pmf.printHashMap();
	}

}
