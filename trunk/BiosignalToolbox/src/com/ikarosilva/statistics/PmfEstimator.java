package com.ikarosilva.statistics;

import java.util.ArrayList;
import java.util.HashMap;
public class PmfEstimator {


	//px : 1 column= probability, 2nd column lower bound, 3rd column upper bound
	private double[][] pmf;
	private HashMap<Integer,Double> pmfHashMap;
	private int Nbins;
	private int M;
	private double[][] minmax; //minimum and maximum values for bins (ie, range)
	int[] mapDim;
	double[] range;
	double[] binScale;
	double[] step;
	double[] unitScale;
	double[] offset;


	public PmfEstimator(){
		Nbins=0;
	}

	public PmfEstimator(int Nbins){
		this.Nbins=Nbins;
	}
	public PmfEstimator(int Nbins, double[][] minmax){
		this.Nbins=Nbins;
		this.minmax=minmax;
	}

	public int getDim(){
		return M;
	}
	private double[] minMax(double[] x){
		//Returns minmax (ie, range ) for a vector
		double[] minMax=new double[2];
		minMax[0]=Double.MAX_VALUE;
		minMax[1]=Double.MIN_VALUE;
		for(int i=0;i<x.length;i++){
			minMax[0]=(minMax[0]>x[i]) ? x[i]:minMax[0];
			minMax[1]=(minMax[1]<x[i]) ? x[i]:minMax[1];
		}
		return minMax;
	}

	private void initializeStates(int M){
		range=new double[M];
		binScale= new double[M];
		step= new double[M];
		unitScale= new double[M];
		offset= new double[M];
		pmfHashMap=new HashMap<Integer,Double>();
		mapDim=new int[M];
		for(int i=0;i<M;i++)
		{
			range[i]= minmax[i][1]-minmax[i][0];
			binScale[i]=(double)(Nbins-1)/range[i];
			step[i]=(double)range[i]/Nbins;
			unitScale[i]=(minmax[i][1]+step[i])/minmax[i][1];
			offset[i]=(double)step[i]/2;
			mapDim[i]=(int) Math.pow(Nbins,M-i-1);
		}
	}
	
	public void equipartition(double[][] x, int N){
		int samples=x[0].length;
		double wcount= (double) 1/samples;
		int key; 
		int binIndex=0;
		Double tmp;
		
		//Initialize parameters for the the pmf based on the data
		M=x.length;
		if(Nbins ==0)
			Nbins=N;
		if(minmax == null){
			minmax=new double[M][2];
			for(int i=0;i<M;i++)
				minmax[i]=minMax(x[i]);
		}
		
		initializeStates(M);	
		/*
		Create HashMap to store bin locations of X1 , X2,...XM and use the HashMap to add to the count. The HashMap is created 
		by normalizing the respective variables and multiplying by the number of bins. The keys to the location in them map are generated by:
		round(normalized*Nbins)
		 */
		double norm;
		for(int i=0;i<samples;i++){
			key=0;
			for(int j=0;j<M;j++){
				//Find the bin location of the sample
				norm=( (x[j][i]-minmax[j][0])*unitScale[j] )-offset[j];
				binIndex= (int) Math.round(norm*binScale[j]);
				//Use integer division to have Nbins*binIndex  
				//on all except last dimension
				key+= (double) mapDim[j]*binIndex; 
			}
			//Map subscript to absolute index
			tmp=pmfHashMap.get(key);
			tmp=(tmp == null) ? wcount:tmp+wcount;
			pmfHashMap.put(key,tmp);
		}
	}
	
	
	
	public int[] sub2Indices(Integer sub){
		int[] indices=new int[M];
		indices[0]=(int) Math.floor(sub/mapDim[0]);
		//System.out.println(sub + "/" + mapDim[0] + " = " + indices[0]);
		for(int i=1;i<M;i++){
			indices[i]=sub;
			for(int k=0;k<i;k++){
				//System.out.println(indices[i] + " - " + indices[k] + " * " + mapDim[k]);
				indices[i]-=indices[k]*mapDim[k];
			}
			//System.out.println(indices[i] + " / " + mapDim[i] + " = " + Math.floor(indices[i]/mapDim[i]));
			indices[i]=(int) Math.floor(indices[i]/mapDim[i]);
			//System.out.println(i + " = " + indices[i] );
		}
		return indices;
	}

	
	public void printHashMap(){
		int[] indices;
		for(Integer thisKey : pmfHashMap.keySet()){
			indices=sub2Indices(thisKey);
			System.out.print("pmf[ " + thisKey + " : ");
			for(int j=0;j<M;j++){
				System.out.print(indices[j] + " ");
			}
			System.out.println(" ]=" + pmfHashMap.get(thisKey));
		}
	}

	
	public static void main(String[] args) {
		//Test the histogram estimation
		ArrayList<Double> y= new ArrayList<Double>();
		HashMap<Integer,Double> hist;
		int bins=3;
		int samples=bins*bins;
		int dim=3;
		double[][] x= new double[dim][samples];
		for(int n=0;n<samples;n++){
			for(int d=0;d<dim;d++)
				x[d][n]=n;//Math.random();
		}
		PmfEstimator pmf=new PmfEstimator(bins);
		pmf.equipartition(x,bins);
		pmf.printHashMap();
	}

}
